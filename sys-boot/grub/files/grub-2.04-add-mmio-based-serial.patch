diff -uNr grub-2.04~rc1/grub-core/Makefile.core.def grub-2.04~rc1.new/grub-core/Makefile.core.def
--- grub-2.04~rc1/grub-core/Makefile.core.def	2019-04-08 07:26:09.000000000 +0200
+++ grub-2.04~rc1.new/grub-core/Makefile.core.def	2019-07-04 17:15:26.359482131 +0200
@@ -2009,6 +2009,7 @@
   name = serial;
   common = term/serial.c;
   x86 = term/ns8250.c;
+  x86 = term/ns8250-pci-mmio.c;
   ieee1275 = term/ieee1275/serial.c;
   mips_arc = term/arc/serial.c;
   efi = term/efi/serial.c;
diff -uNr grub-2.04~rc1/grub-core/term/ns8250.c grub-2.04~rc1.new/grub-core/term/ns8250.c
--- grub-2.04~rc1/grub-core/term/ns8250.c	2017-02-21 20:50:38.000000000 +0100
+++ grub-2.04~rc1.new/grub-core/term/ns8250.c	2019-07-04 19:32:48.744095986 +0200
@@ -44,17 +44,28 @@
 #define DEFAULT_BASE_CLOCK 115200
 #endif
 
+static inline unsigned char io_port_read (struct grub_serial_port *port, grub_addr_t reg)
+{
+  return grub_inb (port->port + reg);
+}
+
+static inline void io_port_write (struct grub_serial_port *port, unsigned char value, grub_addr_t reg)
+{
+  grub_outb (value, port->port + reg);
+}
+
+
 
 /* Convert speed to divisor.  */
-static unsigned short
-serial_get_divisor (const struct grub_serial_port *port __attribute__ ((unused)),
+unsigned short
+serial_get_divisor (const struct grub_serial_port *port,
 		    const struct grub_serial_config *config)
 {
   grub_uint32_t base_clock;
   grub_uint32_t divisor;
   grub_uint32_t actual_speed, error;
 
-  base_clock = config->base_clock ? (config->base_clock >> 4) : DEFAULT_BASE_CLOCK;
+  base_clock = config->base_clock ? (config->base_clock >> 4) : port->board.base_baud;
 
   divisor = (base_clock + (config->speed / 2)) / config->speed;
   if (config->speed == 0)
@@ -94,20 +105,21 @@
   divisor = serial_get_divisor (port, &port->config);
 
   /* Turn off the interrupt.  */
-  grub_outb (0, port->port + UART_IER);
+  port->driver->reg_write (port, 0, UART_IER);
 
   /* Set DLAB.  */
-  grub_outb (UART_DLAB, port->port + UART_LCR);
+  port->driver->reg_write (port, UART_DLAB, UART_LCR);
 
   /* Set the baud rate.  */
-  grub_outb (divisor & 0xFF, port->port + UART_DLL);
-  grub_outb (divisor >> 8, port->port + UART_DLH);
+  port->driver->reg_write (port, divisor & 0xFF, UART_DLL);
+  port->driver->reg_write (port, divisor >> 8, UART_DLH);
+
 
   /* Set the line status.  */
   status |= (parities[port->config.parity]
 	     | (port->config.word_len - 5)
 	     | stop_bits[port->config.stop_bits]);
-  grub_outb (status, port->port + UART_LCR);
+  port->driver->reg_write (port, status, UART_LCR);
 
   if (port->config.rtscts)
     {
@@ -120,17 +132,17 @@
   else
     {
       /* Enable the FIFO.  */
-      grub_outb (UART_ENABLE_FIFO_TRIGGER14, port->port + UART_FCR);
+      port->driver->reg_write (port, UART_ENABLE_FIFO_TRIGGER1, UART_FCR);
 
       /* Turn on DTR, RTS, and OUT2.  */
-      grub_outb (UART_ENABLE_DTRRTS | UART_ENABLE_OUT2, port->port + UART_MCR);
+      port->driver->reg_write (port, UART_ENABLE_DTRRTS, UART_MCR);
     }
 
   /* Drain the input buffer.  */
   endtime = grub_get_time_ms () + 1000;
-  while (grub_inb (port->port + UART_LSR) & UART_DATA_READY)
+  while (port->driver->reg_read (port, UART_LSR) & UART_DATA_READY)
     {
-      grub_inb (port->port + UART_RX);
+      port->driver->reg_read (port, UART_RX);
       if (grub_get_time_ms () > endtime)
 	{
 	  port->broken = 1;
@@ -142,18 +154,18 @@
 }
 
 /* Fetch a key.  */
-static int
+int
 serial_hw_fetch (struct grub_serial_port *port)
 {
   do_real_config (port);
-  if (grub_inb (port->port + UART_LSR) & UART_DATA_READY)
-    return grub_inb (port->port + UART_RX);
+  if (port->driver->reg_read (port, UART_LSR) & UART_DATA_READY)
+    return port->driver->reg_read (port, UART_RX);
 
   return -1;
 }
 
 /* Put a character.  */
-static void
+void
 serial_hw_put (struct grub_serial_port *port, const int c)
 {
   grub_uint64_t endtime;
@@ -167,7 +179,7 @@
   else
     endtime = grub_get_time_ms () + 200;
   /* Wait until the transmitter holding register is empty.  */
-  while ((grub_inb (port->port + UART_LSR) & UART_EMPTY_TRANSMITTER) == 0)
+  while ((port->driver->reg_read (port, UART_LSR) & UART_EMPTY_TRANSMITTER) == 0)
     {
       if (grub_get_time_ms () > endtime)
 	{
@@ -180,7 +192,7 @@
   if (port->broken)
     port->broken--;
 
-  grub_outb (c, port->port + UART_TX);
+  port->driver->reg_write (port, c, UART_TX);
 }
 
 /* Initialize a serial device. PORT is the port number for a serial device.
@@ -190,7 +202,7 @@
    STOP_BIT_LEN is the length of the stop bit. The possible values for
    WORD_LEN, PARITY and STOP_BIT_LEN are defined in the header file as
    macros.  */
-static grub_err_t
+grub_err_t
 serial_hw_configure (struct grub_serial_port *port,
 		     struct grub_serial_config *config)
 {
@@ -228,7 +240,9 @@
   {
     .configure = serial_hw_configure,
     .fetch = serial_hw_fetch,
-    .put = serial_hw_put
+    .put = serial_hw_put,
+    .reg_read = io_port_read,
+    .reg_write = io_port_write,
   };
 
 static char com_names[GRUB_SERIAL_PORT_NUM][20];
@@ -260,6 +274,7 @@
 	com_ports[i].name = com_names[i];
 	com_ports[i].driver = &grub_ns8250_driver;
 	com_ports[i].port = serial_hw_io_addr[i];
+	com_ports[i].board.base_baud = DEFAULT_BASE_CLOCK;
 	err = grub_serial_config_defaults (&com_ports[i]);
 	if (err)
 	  grub_print_error ();
@@ -312,6 +327,7 @@
   p->driver = &grub_ns8250_driver;
   grub_serial_config_defaults (p);
   p->port = port;
+  p->board.base_baud = DEFAULT_BASE_CLOCK;
   grub_serial_register (p);  
 
   return p->name;
diff -uNr grub-2.04~rc1/grub-core/term/ns8250-pci-mmio.c grub-2.04~rc1.new/grub-core/term/ns8250-pci-mmio.c
--- grub-2.04~rc1/grub-core/term/ns8250-pci-mmio.c	1970-01-01 01:00:00.000000000 +0100
+++ grub-2.04~rc1.new/grub-core/term/ns8250-pci-mmio.c	2019-07-04 17:15:26.360482158 +0200
@@ -0,0 +1,186 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2000,2001,2002,2003,2004,2005,2007,2008,2009,2010  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/serial.h>
+#include <grub/ns8250.h>
+#include <grub/types.h>
+#include <grub/dl.h>
+#include <grub/pci.h>
+
+enum { GRUB_SERIAL_PCI_PORT_NUM = 8 };
+
+static inline void
+mmio_write (struct grub_serial_port *port, unsigned char val, grub_addr_t addr)
+{
+  *((volatile char *)(port->mmio_base + addr)) = val;
+}
+
+static inline unsigned char
+mmio_read (struct grub_serial_port *port, grub_addr_t addr)
+{
+  return *((volatile unsigned char *)(port->mmio_base + addr));
+}
+
+struct grub_serial_driver grub_ns8250_pci_mmio_driver =
+  {
+    .configure = serial_hw_configure,
+    .fetch = serial_hw_fetch,
+    .put = serial_hw_put,
+    .reg_write = mmio_write,
+    .reg_read = mmio_read,
+  };
+
+static char com_names[GRUB_SERIAL_PCI_PORT_NUM][20];
+static struct grub_serial_port ports[GRUB_SERIAL_PCI_PORT_NUM];
+
+struct drv_data
+{
+  unsigned cards;
+  unsigned num_ports;
+};
+
+static void
+read_bars(grub_pci_device_t dev, struct grub_serial_board *board)
+{
+  for (unsigned bar = 0; bar < NUM_BARS; ++bar)
+    {
+      int a = GRUB_PCI_REG_ADDRESSES + bar * 4;
+      grub_pci_address_t addr = grub_pci_make_address(dev, a);
+      unsigned v = grub_pci_read(addr);
+      grub_pci_write(addr, ~0U);
+      unsigned x = grub_pci_read(addr);
+      grub_pci_write(addr, v);
+
+      if (!v)
+        continue;
+
+      int s;
+      for (s = 2; s < 32; ++s)
+        if ((x >> s) & 1)
+          break;
+
+      if (0)
+        grub_printf("bar=%x (%s, sz=%d)\n", v, (v & 1) ? "IO" : "MEM", 1 << s);
+
+      board->bars[bar].base = v & ~3UL;
+      board->bars[bar].len = 1 << s;
+      board->bars[bar].type = (v & 1) ? IO_BAR : MEM_BAR;
+    }
+}
+
+static
+void enable_mmio(grub_pci_device_t dev)
+{
+  grub_pci_address_t addr = grub_pci_make_address(dev, GRUB_PCI_REG_COMMAND);
+  unsigned cmd = grub_pci_read_word(addr);
+  grub_pci_write_word(addr, cmd | GRUB_PCI_COMMAND_MEM_ENABLED);
+}
+
+static int
+ns8250_pci_mmio_iter(grub_pci_device_t dev, grub_pci_id_t pciid, void *data)
+{
+  unsigned vendor, device;
+  struct drv_data *d = (struct drv_data *)data;
+
+  if (d->num_ports >= GRUB_SERIAL_PCI_PORT_NUM)
+    return 0;
+
+  vendor = pciid & 0xffff;
+  device = pciid >> 16;
+
+  if (vendor == 0x1415 && device == 0xc158)
+    {
+      struct grub_serial_port *port = &ports[d->num_ports];
+      struct grub_serial_board *b = &ports[d->num_ports].board;
+
+      if (0)
+        grub_printf("Found OXSEMI PCI UART\n");
+
+      read_bars(dev, b);
+
+      // this card has two serial ports
+      port->board.num_ports = 2;
+      port->board.base_baud = 4000000;
+      port->board.port_offset = 0x200;
+      port->board.base_offset = 0x1000;
+
+      port->pcidev.bus = dev.bus;
+      port->pcidev.device = dev.device;
+      port->pcidev.function = dev.function;
+      port->port_num = 0;
+      port->card = d->cards;
+      port->mmio_base = port->board.bars[0].base + port->board.base_offset +
+                         port->port_num * port->board.port_offset;
+      d->num_ports += 1;
+
+      if (d->num_ports >= GRUB_SERIAL_PCI_PORT_NUM)
+        return 0;
+
+      port = &ports[d->num_ports];
+
+      port->board.num_ports = 2;
+      port->board.base_baud = 4000000;
+      port->board.port_offset = 0x200;
+      port->board.base_offset = 0x1000;
+
+      port->pcidev.bus = dev.bus;
+      port->pcidev.device = dev.device;
+      port->pcidev.function = dev.function;
+      port->port_num = 1;
+      port->card = d->cards;
+      port->mmio_base = port->board.bars[0].base + port->board.base_offset +
+                         port->port_num * port->board.port_offset;
+
+      enable_mmio (dev);
+
+      d->num_ports += 1;
+      d->cards += 1;
+    }
+
+  return 0;
+}
+
+void
+grub_ns8250_pci_mmio_init (void)
+{
+  struct drv_data data = { .cards = 0, .num_ports = 0 };
+  unsigned i;
+
+  for (i = 0; i < GRUB_SERIAL_PCI_PORT_NUM; ++i)
+    {
+      ports[i].card = ~0UL;
+      ports[i].port_num = -1;
+    }
+
+  grub_pci_iterate(ns8250_pci_mmio_iter, &data);
+
+  for (i = 0; i < data.num_ports; i++)
+    {
+      grub_err_t err = 0;
+
+      grub_snprintf (com_names[i], sizeof (com_names[i]), "pci:%lu:%u",
+                     ports[i].card, ports[i].port_num);
+      ports[i].name = com_names[i];
+      ports[i].driver = &grub_ns8250_pci_mmio_driver;
+      err = grub_serial_config_defaults (&ports[i]);
+      if (err)
+        grub_print_error ();
+
+      grub_serial_register (&ports[i]);
+    }
+}
diff -uNr grub-2.04~rc1/grub-core/term/serial.c grub-2.04~rc1.new/grub-core/term/serial.c
--- grub-2.04~rc1/grub-core/term/serial.c	2017-02-21 20:50:38.000000000 +0100
+++ grub-2.04~rc1.new/grub-core/term/serial.c	2019-07-04 17:15:26.360482158 +0200
@@ -194,8 +194,12 @@
 
   if (state[OPTION_UNIT].set)
     {
-      grub_snprintf (pname, sizeof (pname), "com%ld",
-		     grub_strtoul (state[0].arg, 0, 0));
+      if (grub_memcmp (state[OPTION_PORT].arg, "pci:", 4) == 0)
+          grub_snprintf(pname, sizeof (pname), "%s", state[1].arg);
+      else
+          grub_snprintf (pname, sizeof (pname), "port%lx",
+                         grub_strtoul (state[1].arg, 0, 0));
+
       name = pname;
     }
 
@@ -438,6 +442,7 @@
 
 #if !defined (GRUB_MACHINE_EMU) && !defined(GRUB_MACHINE_ARC) && (defined(__mips__) || defined (__i386__) || defined (__x86_64__))
   grub_ns8250_init ();
+  grub_ns8250_pci_mmio_init ();
 #endif
 #ifdef GRUB_MACHINE_IEEE1275
   grub_ofserial_init ();
diff -uNr grub-2.04~rc1/include/grub/ns8250.h grub-2.04~rc1.new/include/grub/ns8250.h
--- grub-2.04~rc1/include/grub/ns8250.h	2017-02-21 20:50:38.000000000 +0100
+++ grub-2.04~rc1.new/include/grub/ns8250.h	2019-07-04 17:15:26.360482158 +0200
@@ -20,6 +20,8 @@
 #ifndef GRUB_NS8250_HEADER
 #define GRUB_NS8250_HEADER	1
 
+#include <grub/serial.h>
+
 /* Macros.  */
 
 /* The offsets of UART registers.  */
@@ -75,6 +77,52 @@
 
 grub_port_t
 grub_ns8250_hw_get_port (const unsigned int unit);
+
+/**
+ * \brief Configure and setup a serial port.
+ *
+ * \param port    The serial port that should be set up.
+ * \param config  The configuration that should be applied to the serial port.
+ *
+ * \retval GRUB_ERR_NONE          Serial port setup and configured successfully.
+ * \retval GRUB_ERR_BAD_ARGUMENT  Unsupported serial configuration.
+ */
+grub_err_t
+serial_hw_configure (struct grub_serial_port *port,
+                     struct grub_serial_config *config);
+
+/**
+ * \brief Calculate the divisor for a given baud rate.
+ *
+ * \param port    The serial port for which the divisor needs to be calculated.
+ * \param config  The configuration with the wanted baud rate.
+ *
+ * \retval 0   No divisor could be calculated
+ * \retval >0  The divisor that needs to be programmed into the UART.
+ */
+unsigned short
+serial_get_divisor (const struct grub_serial_port *port,
+                    const struct grub_serial_config *config);
+
+/**
+ * \brief Send a character over a serial port.
+ *
+ * \param port  The serial port over which the character should be send.
+ * \param c     The character to send over the serial port.
+ */
+void
+serial_hw_put (struct grub_serial_port *port, const int c);
+
+/**
+ * \brief Read a character from a serial port.
+ *
+ * \param port  The serial port to read the character from.
+ *
+ * \return  The character read from the serial port.
+ */
+int
+serial_hw_fetch (struct grub_serial_port *port);
+
 #endif
 
 #endif /* ! GRUB_SERIAL_MACHINE_HEADER */
diff -uNr grub-2.04~rc1/include/grub/pci.h grub-2.04~rc1.new/include/grub/pci.h
--- grub-2.04~rc1/include/grub/pci.h	2017-07-08 10:31:21.000000000 +0200
+++ grub-2.04~rc1.new/include/grub/pci.h	2019-07-04 17:15:26.361482186 +0200
@@ -102,6 +102,14 @@
 
 typedef grub_uint32_t grub_pci_id_t;
 
+enum { NO_BAR, IO_BAR, MEM_BAR };
+struct grub_pci_resource
+{
+  unsigned type;
+  unsigned long base;
+  unsigned long len;
+};
+
 #ifdef GRUB_MACHINE_EMU
 #include <grub/pciutils.h>
 #else
diff -uNr grub-2.04~rc1/include/grub/serial.h grub-2.04~rc1.new/include/grub/serial.h
--- grub-2.04~rc1/include/grub/serial.h	2017-02-21 20:50:38.000000000 +0100
+++ grub-2.04~rc1.new/include/grub/serial.h	2019-07-04 17:15:26.361482186 +0200
@@ -23,6 +23,7 @@
 #include <grub/types.h>
 #if defined(__mips__) || defined (__i386__) || defined (__x86_64__)
 #include <grub/cpu/io.h>
+#include <grub/pci.h>
 #endif
 #include <grub/usb.h>
 #include <grub/list.h>
@@ -43,6 +44,9 @@
 			   struct grub_serial_config *config);
   int (*fetch) (struct grub_serial_port *port);
   void (*put) (struct grub_serial_port *port, const int c);
+  void (*reg_write) (struct grub_serial_port *port, unsigned char value,
+                     grub_addr_t reg);
+  unsigned char (*reg_read) (struct grub_serial_port *port, grub_addr_t reg);
   void (*fini) (struct grub_serial_port *port);
 };
 
@@ -71,6 +75,17 @@
   int rtscts;
 };
 
+enum { NUM_BARS = 6 };
+struct grub_serial_board
+{
+  unsigned num_ports;
+  unsigned base_baud;
+  unsigned port_offset;
+  unsigned base_offset;
+
+  struct grub_pci_resource bars[NUM_BARS];
+};
+
 struct grub_serial_port
 {
   struct grub_serial_port *next;
@@ -80,6 +95,7 @@
   struct grub_serial_config config;
   int configured;
   int broken;
+  struct grub_serial_board board;
 
   /* This should be void *data but since serial is useful as an early console
      when malloc isn't available it's a union.
@@ -91,6 +107,13 @@
 #endif
     struct
     {
+      grub_pci_device_t pcidev;
+      unsigned long card;
+      grub_port_t port_num;
+      grub_addr_t mmio_base;
+    };
+    struct
+    {
       grub_usb_device_t usbdev;
       int configno;
       int interfno;
@@ -177,6 +200,7 @@
 
 #if defined(__mips__) || defined (__i386__) || defined (__x86_64__)
 void grub_ns8250_init (void);
+void grub_ns8250_pci_mmio_init (void);
 char *grub_serial_ns8250_add_port (grub_port_t port);
 #endif
 #ifdef GRUB_MACHINE_IEEE1275
@@ -195,6 +219,7 @@
 
 struct grub_serial_port *grub_serial_find (const char *name);
 extern struct grub_serial_driver grub_ns8250_driver;
+extern struct grub_serial_driver grub_ns8250_pci_mmio_driver;
 void EXPORT_FUNC(grub_serial_unregister_driver) (struct grub_serial_driver *driver);
 
 #ifndef GRUB_MACHINE_EMU
